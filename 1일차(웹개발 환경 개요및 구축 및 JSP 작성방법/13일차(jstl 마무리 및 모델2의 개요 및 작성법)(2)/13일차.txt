13일차(jstl 태그의 마무리 및 모델2의 개요 작성법)

-------------------------------------------------
forEach(8).jsp

<%
   java.util.HashMap mapData=new java.util.HashMap();
   mapData.put("name","홍길동");//map.get(키명(name))
   mapData.put("today",new java.util.Date());//날짜객체
   //int [] intArray={1,2,3,4,5};//배열도 객체다
%>
<c:set var="intArray"  value="<%=new int[] {1,2,3,4,5} %>" />
<c:set var="map" value="<%=mapData %>" />
<html>
<head>
<meta charset="UTF-8">
<title>forEach구문</title>
</head>
<body>
<%
   //1~100까지의 합중에서 홀수값을 출력
******************************************************
   int sum=0;
   for(int i=1;i<=100;i+=2){//c:forEach var="초기변수"  begin="시작값" end="종료값"
	   //if(i%2==1)                // step="증가치" (default  step="1") 이 아닌경우 써줘야된다.
	   sum+=i;//sum=sum+i //<c:set var="sum"  value="${sum+i}" /> 
	                                           //동일한 변수 한번사용 ->기존의 변수에 값을 새로운값으로 저장(변경)
   }
   out.println(sum);
%>
*******************************************************
<h4>1~100까지의 홀수의 합</h4>
<c:set var="sum"  value="0" />
<c:forEach var="i" begin="1" end="100" step="2">
	<c:set var="sum"  value="${sum+i}" />
</c:forEach>
결과:${sum}
<hr>
<h4>배열의 값,컬렉션의 값을 출력</h4>
<%--   <c:set var="intArray"  value="<%=new int[] {1,2,3,4,5} %>" />    
          items="${외부에서 불러올 객체명}"
 --%>

<c:forEach var="i"  items="${intArray}"  begin="2"  end="4">
    [${i}]
</c:forEach>
<h4>Map(key,value)</h4>
<!-- var(객체명) items(배열 또는 컬렉션객체)  i는 hashmap객체에서 꺼낸 각각의 객체를 의미-->
 <c:forEach var="i"  items="${map}">
         ${i.key}=${i.value}<br>
 </c:forEach>

import(9).jsp

<%
  //String url="http://www.chosun.com";
  //네이버와 다음은 외부에서 접근이 못하게 설정->302 (접근금지)
  //<c:import url="접속사이트 주소" var="접속해서 가져올 데이터 저장할 변수명"
  //escapeXml="true" ->태그자체를 문자열로 인식->문자형태로 출력
  //escapeXml="false"->본문내용 그대로 (html를 실행한 결과 그대로)
%>
<c:set var="url" value="http://www.empas.com" />
<c:import url="${url}" var="u" />
<c:out value="${url}" />가져옵니다.<p>
<c:out value="${u}" escapeXml="false" />

<h4>내부자원을 가져오기</h4>
<!-- chooseTag(5).jsp?name2=bk (Get방식으로 매개변수 전달) -->
<c:set var="url" value="chooseTag(5).jsp" />
<c:import url="${url}" var="u">
	<c:param name="name2"  value="bk" />
</c:import>
<c:out value="${u}" escapeXml="false" />
</body>
</html>
-------------------------------------------------------------------
jstlfmt(10).jsp

<fmt:setLocale value="ko-KR" />
 <h1><!-- value(출력할값) ,type(숫자,통화,퍼센트 단위를 지정) -->
 number:<fmt:formatNumber value="9876543.61"  type="number"   /><br>
 currency:<fmt:formatNumber value="9876543.61"  type="currency"   /><br>
 percent:<fmt:formatNumber  type="percent" >
                     9876543.61
           </fmt:formatNumber><br>
 <!-- 사용자정의 형식포맷으로 지정하고 싶다. pattern=설정할 타입포맷 지정 -->
 pattern=".0000":<fmt:formatNumber value="9876543.61"  pattern=".0000"   /><br>
 pattern="#,#00.0#":<fmt:formatNumber value="9876543.61"  pattern="#,#00.0#"   /><br>
 
 <hr>
 <jsp:useBean id="now" class="java.util.Date" />
 <c:out value="${now}" /><p>
 <!-- 
     formatDate액션태그 value="출력할값"  type(날짜만,시간만, 둘다 출력)
  -->
  date:<fmt:formatDate value="${now}"   type="date" /><br>
  time:<fmt:formatDate value="${now}"   type="time" /><br>
  both:<fmt:formatDate value="${now}"   type="both" /><br>
 
 <!-- dateStyle(날짜만 세부적으로 설정할때),timeStyle(시간을 세부적으로 설정)  -->
 default:<fmt:formatDate value="${now}" type="both" 
                               dateStyle="default" timeStyle="default" /><br>
                               
 short:<fmt:formatDate value="${now}" type="both" 
                               dateStyle="short" timeStyle="short" /><br>
                               
 medium:<fmt:formatDate value="${now}" type="both" 
                               dateStyle="medium" timeStyle="medium" /><br>
                               
 long:<fmt:formatDate value="${now}" type="both" 
                               dateStyle="long" timeStyle="long" /><br>
                               
 full:<fmt:formatDate value="${now}" type="both" 
                               dateStyle="full" timeStyle="full" /><br>
 pattern:"yy년 MM월 dd일 HH시 mm분 ss초":  
   <fmt:formatDate value="${now }"  type="both"
                             pattern="yy년 MM월 dd일 HH시 mm분 ss초"     /><br>  

         요청에 따라서 처리되는 방식이 다를뿐

 Model 1---Model 2
                el,jstl ->모델2와는 상관이 없다.(화면에 출력->편리성)
                                                         단점->유지보수가 쉽지않다.
----------------------------------------------------------------------
 ** Model2의 개요 및 작성법 **


17장. MVC 구조 (모델2) ==>스프링(MVC구조 모양으로 되어있다.)

   웹프로그래밍->초(모델1)-중(모델2)-고급(스프링)->컨트롤러 (X)

 **  모델 (Model) , 뷰(View)  컨트롤러(Controller)(O)

1.Model(모델)=>데이터가 저장되는 부분=>빈즈부분(DB)
                      BoardDTO(저장),BoardDAO=>테이블갯수,필드갯수 증가

2.View(화면 출력)->html,css,js,jsp파일+자바코드<% ~ %>
------------------------------------------------------------------------
3.Controller->Model--Controller-->View에 전달해서 보여줄것인가를 결정

모델2->무조건 el,jstl을 사용한다는 것을 의미하지 않는다.
            화면 편리성을 추구

컨트롤러를 배운다는 말과 같다.
=======================
모델1  요청(jsp, html)-------------------->처리하는 페이지(jsp)
          버튼,링크문자열클릭--------->list.jsp(자바코드+화면출력
                                                                              html,css)
http://localhost:8090/JspBoard/list.jsp

      모델1 vs 모델2의 차이점,공통점,장점,단점

**********
 모델1의 장점
**********

  1.중소규모의 사이트 작성에 적합
  2.적은인원으로도 구성이 가능(4~5)

*********
 모델1의 단점 
*********

          페이지가 많아지면 유지보수가 어려워진다.

 1. jsp=>자바소스코드+화면출력(html) ->혼영=>유지보수가 어려워진다.
 2. 중복된 코드가 많아진다.(페이지별로)

    클--------list.jsp-------------->서(list.jsp(자바코드+html실행)
                                                        M,V(화면에 보여주는부분)이 섞여있는 구조
                                                        C,V
   ex)회원제로 운영->20페이지다
   <%
       String mem_id=(String)session.getAttribute("idKey");
    %>
   <% if (mem_id!=null) %>
--------------------------------------------------------------------------
******
모델2
****

모델2의 장점

1.대규모 사이트에 작성하는데 적합한 구조(대기업)
2.역할이 분담이 나누어져 있어서 유지보수가 쉽다.(M,C(개발)---V(디자인)

단점

1.개개인의 실력이 향상을 요구->서블릿이 중심
2.구성원이 10인 이상을 요구

************************************

M->데이터 저장부분

V->처리결과를 받아서 출력만 담당
      1)요청을 받는 부분->Controller에게 전담
      2)뷰에서 존재하는 자바코드->요청명령어 클래스에서 처리
                                             (=액션클래스(모델2)->컨트롤러 클래스(스프링))

C-->1)요청을 받아서  그요청에 맞는 요청명령어 클래스를 선택->처리
                                                               |
                                                   빈즈메서드 호출(getArticles())
                                                          DB접속
==========================================
ServletTest2 =>프로젝트명

 컨트롤러 
 서블릿
 =>MVC 개요 예제
==================
모델1->모델2로 작업
============
모델2의 구조와 흐름을 이해=>ServletTest2

  test
  SimpleController

@WebServlet("/SimpleController")
public class SimpleController extends HttpServlet {
	
     //Get으로 요청(접속)
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		processRequest(request,response);
	}

     //Post으로 요청
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		processRequest(request,response);
	}

	//Get or Post 상관없이 동일한 처리를 해주고 싶다.
	//외부에서 직접 호출 하지 못하게 설정하고 내부에서만 사용할 수있는 메서드를 작성->private
	private void processRequest(HttpServletRequest request,HttpServletResponse response)
	                                          throws ServletException,IOException {
		//1.요청명령어를 입력받아서 분석
		String type=request.getParameter("type");
		System.out.println("type=>"+type);
		//2.요청명령어->greeting->안녕하세요, date=>오늘날짜 출력, X->invalid Type 화면에 출력
		Object resultObject=null;//String or java.util.Date 둘다 저장이 가능한 자료형
		//3.요청명령어 분리
		if(type==null  || type.contentEquals("greeting")) {
			resultObject="안녕하세요!!!";
		}else if(type.contentEquals("date")) {
			resultObject=new java.util.Date();
		}else { //전혀 모르는 매개변수를 전달
			resultObject="Invalid Type!";
		}
		
		//4.처리결과->simpleview.jsp에 전송->서버에 저장->페이지 이동
		request.setAttribute("result", resultObject);//forward 액션태그
		
		//5.forward액션태그를 사용X->forward시켜주는 객체가 필요=>RequestDispatcher객체
		//데이터를 공유받아서 이동할 페이지의 정보를 가진 객체
		RequestDispatcher dispatcher=request.getRequestDispatcher("/simple.jsp");
		//6.forward->데이터를 공유시키면서 페이지 이동
		dispatcher.forward(request, response);//요청,응답
	}
	
}
-----------------------------------------------------------------------
http://localhost:8090/ServletTest2/SimpleController

처리결과:안녕하세요!!!
처리결과2:안녕하세요!!!

http://localhost:8090/ServletTest2/SimpleController?type=greeting
                                                                           ?type=date

처리결과:Fri Aug 30 10:14:26 KST 2019
처리결과2:Fri Aug 30 10:14:26 KST 2019


http://localhost:8090/ServletTest2/SimpleController?type=imsi

처리결과:Invalid Type!
처리결과2:Invalid Type!

<%
    //request.setAttribute("result", resultObject);
    //requset.getAttribute("result")//키명
    //${키명}
%>
처리결과:<%=request.getAttribute("result") %><br>
처리결과2:${result}
=======================================

모델1 게시판->모델2로 변환(구조만 이해)+el,jstl(모든 태그)jsp
==================================

 모델2로의 설계 ->요청명령어를 만든다.=>기능(화면에 보여주는 페이지 와 연관)
                   ->jsp요청(X) ->~.do

                         인터페이스->클래스는 다 다르지만 요청을 받아서 처리해주는 메서드가
                                           필요(공통의 메서드가 필요)

요청명령어?->  1.게시판의 글목록보기->/list.jsp(X)=>/list.do->ListAction
                    2.글쓰기,  /writeForm.do->WriteFormAction(폼)
                                 /writePro.do
                    3.상세보기,/content.do
                    4.글수정, /updateForm.do
                    5.글삭제/deleteForm.do
                    6.글검색=>6개-->처리해주는 클래스도 6개->객체->메서드 필요
                                                (=액션클래스=컨트롤러 클래스)
              =>공통점=>요청에 따라서 페이지가 이동이 되면서 처리가 된다.(공통의 메서드작성)

        
 --------------------------------------------------------------------------
                    요청명령어------요청처리클래스가 하나씩 증가
                                       (=명령어처리클래스=액션클래스=컨트롤러클래스)
     주제->영화예매,사이트                                 모델2          (스프링)
--------------------------------------------------------------------------

요청명령어------------------->확장자는 여러분 주제의 키워드를 중심으로 작성할것.
->~.do(스프링)->디폴트 
~.mov
~.nhn
~.test

======================================
 공통의 메서드를 작성->인터페이스

0.인터페이스 작성=>CommandAction

package lys.board;

//기능은 다르지만 요청을 받아서 처리해주는 메서드를 공통의 메서드로 작성하기위해서 인터페이스를 작성
import javax.servlet.http.*;//HttpServletRequest,HttpServletResponse

public interface CommandAction {
     //이동할 페이지의 경로와 페이지명이 필요->반환값(String)=>스프링(ModelAndView)
	public String requestPro(HttpServletRequest request,HttpServletResponse response)
	                                 throws Throwable;
}


1.요청명령어->컨트롤러에 요청명령어를 구분소스 계속 작성...(분석)

                       if(글목록을 요청) { if(type.equals("/list.do") =>/list.jsp(X)
			글목록에 해당클래스 생성->메서드호출
                                     new ListAction();  ->list()
		}else if(type.equals("/writePro.do") {
			글쓰기에 해당클래스 생성->메서드호출
                                     new WriteAction()->write()
		}else {
			resultObject="Invalid Type";
		}
                          ,,,,

****2.컨트롤러 하나 ->소스계속해서 X

 동일한 소스->그대로 사용=>인터페이스를 이용->요청명령어만 따로 작성
               1.요청명령어만 따로 파일로 만들어서 불러와서 작업
               2.객체형변환을 이용
***************************************************

JspBoard2
       |
        -src
           controller
                ControllerAction(4)=>시작(컨트롤러)
          action (인터페이스를 작성)
              CommandAction->requestPro(request,response)
                           상속-------->계속사용(0)
       |
        -WebContent->list.jsp~(el,jstl로 모두 변경)
                 |                     자바에서 환경설정~.properties
                  -WEB-INF->commandPro.properties(2) ->요청명령어를 등록
                                 /가상경로/~/요청명령어=패키지명.명령어처리클래스
                         |
                          -lib->standard.jar,jstl.jar복사(1)=>el,jstl문법을 사용하기위해서

                              #key(command~.do)=value(package...classname)
                               /list.do=action.ListAction

                               #/notice/list.do= >공지사항

                               #/member/list.do =>회원리스트

                           web.xml(3)->컨트롤러 역할을 해주는 서블릿을 지정
                                        ->commandPro.properties 읽어들일 수 있도록
                                           환경설정을 해야 한다.

  *.do

  /*->WebContent을 거치는 모든 요청명령어 처리
         확장자에 상관없어

<!-- 요청->web.xml (1.컨트롤러역할을 해주는 서블릿을 등록) -->
  <servlet>
    <servlet-name>실행시킬 서블릿의 별칭이름</servlet-name>->3)
    <servlet-class>패키지명...실행시킬서블릿클래스명</servlet-class>->4)
    <init-param> =>서블릿을 실행시킬때 파라미터를 지정해서 외부의 파일을 불러올
                             때 사용하는 태그를 지정
        <param-name>불러올 파라미터명설정</param-name>
        <param-value>경로포함해서 불러올 환경설정파일명(~.properties)</param-value>
    </init-param>
  </servlet>
  
  <!-- 2.어떻게 요청이 들어왔을때 처리할 수 있도록 설정(keyword등로) -->
  <servlet-mapping>                                       ->2)
     <servlet-name>요청명령어에 따라서 실행할 서블릿클래스명</servlet-name>
     <url-pattern>웹상에서 요청할 명령어를 등록</url-pattern>  =>1)
  </servlet-mapping>
=====================================
<!-- 요청->web.xml (1.컨트롤러역할을 해주는 서블릿을 등록) -->
  <servlet>
    <servlet-name>ControllerAction</servlet-name>
    <servlet-class>controller.ControllerAction</servlet-class>
    <init-param>
        <param-name>propertyConfig</param-name>
        <param-value>C:/webtest/4.jsp/sou/JspBoard2/WebContent/WEB-INF/commandPro.properties</param-value>
    </init-param>
  </servlet>
  
  <!-- 2.어떻게 요청이 들어왔을때 처리할 수 있도록 설정(keyword등로) -->
  <servlet-mapping>
     <servlet-name>ControllerAction</servlet-name>
     <url-pattern>*.do</url-pattern>
  </servlet-mapping>


 dbtest복사=>경로
***** DBConectionMgr.java 소스 편집**************

 //(1) 멤버변수 선언
    private String _driver,_url,_user,_password;

//(2)dbmysql.properties파일을 읽어들여서 키->값을 불러오기
    public DBConnectionMgr() throws IOException {
    	Properties props=new Properties();
    	FileInputStream in=new FileInputStream
    			("C:/webtest/4.jsp/sou/JspBoard2/src/main/webapp/dbtest/dbmysql.properties");
    	props.load(in);//파일의 내용 메모리에 불러오기
    	in.close();
    	_driver=props.getProperty("jdbc.drivers");
    	//드라이브만 시스템에 반영
    	if(_driver!=null)  System.setProperty("jdbc.drivers", _driver);//등록
    	//-------------------------------------------------------------------
    	_url=props.getProperty("jdbc.url");
    	_user=props.getProperty("jdbc.username");
    	_password=props.getProperty("jdbc.password");
    	System.out.println("_driver=>"+(_driver)+",_url=>"+(_url));
    	System.out.println("_user=>"+(_user)+",_password=>"+(_password));
    }

    /** Use this method to set the maximum number of open connections before
     unused connections are closed.
     */
  
    //커넥션풀을 얻어오는 정적메서드
    public static DBConnectionMgr getInstance() throws Exception{
        //커넥션풀이 생성이 안되어있다면                      ============
		if (instance == null) {
            synchronized (DBConnectionMgr.class) {
                //생성이 안되어있다면
				if (instance == null) {
					//객체생성
                    instance = new DBConnectionMgr();
                }
            }
        }
        return instance;//호출한 클래스쪽으로 반환
    }
============모델2의 환경설정 끝==============================
   웹사이트=>커넥션풀을 사용하지 않으면 속도가 느려진다.
               요청할때 =>커넥션객체->만들어서 주면 시간이 너무 오래걸린다.

  동시접속
  커넥션풀=> 미리 평균적으로 커넥션객체를 만들어둔다.=>대여=>반납
===============================
//시용자의 요청을 분석해서 해당 작업을 처리
    private void requestPro(HttpServletRequest request,
    		                           HttpServletResponse response) 
    throws ServletException, IOException {
    
   	  String view=null;//요청명령어에 따라서 이동할 페이지 저장
      // /list.do=action.ListAction, 
   	  // /writeForm.do=action.WriteFormAction,,,,
   	  //ListAction com=new ListAction();
   	  //WriteFormAction com=new WriteFormAction;,,,
   	  CommandAction com=null;//어떠한 자식클래스의 객체라도 부모형으로 형변환
      //CommandAction com=new ListAction();
      //CommandAction com=new WriteFormAction();
      try {
    	  //1.요청명령어 분리
    	  String command=request.getRequestURI();// /JspBoard2/list.do
    	  System.out.println
    	  ("request.getRequestURI()=>"+request.getRequestURI());
    	  System.out.println
    	  ("request.getContextPath()=>"+request.getContextPath());
    	  // /JspBoard2/list.do
    	  // /JspBoard2  =>문자열을 서로 비교했을때 일치하는 위치
    	  if(command.indexOf(request.getContextPath())==0) {
    		 command=command.substring
    				 (request.getContextPath().length());
    		 System.out.println("실질적인 command=>"+command);
    		 // /list.do
    	  }
    	  //요청명령어->/list.do->action.ListAction객체
    	  //                        ->requestPro()를 호출하기위해서
    	  com=(CommandAction)commandMap.get(command);
    	  System.out.println("com=>"+com);///action.ListAction@주소값
    	  view=com.requestPro(request, response);
    	  System.out.println("view=>"+view);// /list.jsp
      }catch(Throwable e) {
    	  throw new ServletException(e);//서블릿 예외처리
      }
    	
   	 //위에서 요청명령어에 해당하는 view로 데이터를 공유시키면서 이동
   	 //forward() 필요
     RequestDispatcher dispatcher=
    		 request.getRequestDispatcher(view);// "/list.jsp"
     dispatcher.forward(request, response); // /list.jsp
    }




