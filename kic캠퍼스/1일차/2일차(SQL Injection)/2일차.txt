2일차(SQL Injection) ->최종 프로젝트
 
  BoardDAO,MemberDAO

웹 어플리케이션에서 데이터베이스로 전달되는 SQL 쿼리값을 변조(값을변경) 및 삽입(더해서)하여 
비정상적인 방법으로 데이터베이스에 접근 하는 공격기법

http://jungcw.tistory.com/27 사이트 참조

 
   1.   ' or 1=1-- =>input box에 입력

   2.   " or 1=1--

   3.   or 1=1--

   4.   ' or 'a'='a

   5.   " or "a"="a

   6.   ') or ('a'='a


출처: https://jungcw.tistory.com/27 [Ddol2's Tistory Blog~♡]


********************************************************************
sql="select id,passwd from member where  id='"+id+"'"+" and passwd='"+passwd+"'";
pstmt=con.prepareStatement(sql);
rs=pstmt.executeQuery();
System.out.println("sql=>"+sql);
*********************************************************************
                                                                        SQL구문 변조
sql=>select id,passwd from member where  id='' or 1=1--' and passwd='' or 1=1--'


====================================================
sql=>select id,passwd from member where  id='' or 1=1 
=>or 연산자 구문때문에 앞의 문장이 실행이 되지 않아도 1=1 문장이 참이기때문에 SQL수행이 된다.
  -- 주석표시이기때문에 뒤의 SQL문장을 수행하지 않는다.

====================================================
 시큐어코딩=>직접 매개변수를 입력받아서 SQL구문에 적용X
             =>?을 SQL구문에 작성하시면 된다.

 MyBatis==>#{매개변수} =>? 역할을 이미 하는것이기때문에 시큐어코딩이 적용이 된상태
****************************************************************

  *** 회원로그인 할때  지침서 ***

로그인 인증 프로그램의 검토와 대책



  우선 각각의 Server Side Script 마다 약간의 차이는 있지만 그 원리는 동일합니다.


  가.  계정을 입력받는 값의 특수 문자를 허용해서는 안됩니다. =><,>,(,) (자바스크립트취약점) XSS

  ', --, ++, ;, :, " 등의 특수 문자를 입력받지 않거나 입력 받아도 다른 문자로 대체해 주어야 합니다.
                         replaceAll문자열의 메서드를 이용
 
  나. SQL에 문의 키워드도 사용하지 못하게 해야 합니다.=>변조 불가능하게 설정

  insert, select, update, delete, union등도 입력 받지 못하게 해야 합니다.

 ***************************************************************************
  다. DB에러가 발생하는 경우 에러 메시지를 보여주지 말아야 합니다. =>개발자가 직접 작성한 에러페이지를 내보낼수
                                                                                       있도록 하는것이 중요하다.
****************************************************************************
 

   에러 메시지를 이용하여 유추해서 우회할 수 있습니다.=>사이트 침입할 수 있기때문에 조심

   해킹의 빌미를 제공해서는 안됩니다.


 라. 기본적으로 제공되는 프로시저를 가급적이면 사용하지 말아야 합니다.

 

   시스템 명령을 실행하는 xp_cmdshell 등의 프로시저.


출처: https://jungcw.tistory.com/27 [Ddol2's Tistory Blog~♡]
============================================

/*   MySQL */ =>id,passwd,url,정보들은 가능한 소스코드에 작성X
                      =>Properties객체를 통해서 중요정보들은 불러올 수 있도록 설계(시큐어코딩)
                          모델2

	private String _driver = "org.gjt.mm.mysql.Driver",
    _url = "jdbc:mysql://127.0.0.1:3306/mydb?useUnicode=true&characterEncoding=UTF-8",
    _user = "root",
    _password = "1234"; 

********************
=>암호화의 개요 및 작성법
********************

 WebSecure2=>프로젝트 작성=>암호화기법을 적용

 ** 용어정리 **

1.plain text 또는 cleartext(평문):전달해야 할 내용
2.ciphertext(암호문):암호화한 내용
3.encryption(암호화):평문을 암호문으로 바꾸는 것.
4.decryption(복호화):암호문을 평문으로 복구하는 것.
 ==>인증키
5.symmetric key(대칭키):평문을 암호문으로, 암호문을 평문으로 생성하는 키 값이 같다.
6.cryptographic algorithm 또는 cipher:암호화와 복호화를 위해 사용하는 수학 함수.
     일반적으로 암호화를 위한  함수와 복호화를 위한 함수 두 개로 이루어진다.
                
  =>그림

DES(Data Encryption Standard):64비트 키 크기를 가진 블록 암호문
RC2:블록 암호문
RC4:스트림 암호문
RC5:블록 암호문
IDEA:128비트 키 크기를가진 블록암호문
Skipjack:80비트 크기를 가진 스트림 암호문

package encrypt;

//암호화->java.security패키지 필요
import java.security.*; //key(암호화를 시킬 정보),InvalidKeyException(키 에러발생)
import javax.crypto.*;//BadPaddingException(패팅에러유발)
                                 //Cipher(암호화를 시킬때 필요로하는 객체),KeyGenerator(키 작성)

//패딩시켜주는 클래스->평문(안녕하세요?)->미완성된 암호화문자열끝에 임의로 문자열을 자동으로
                                                     //넣어주는것(=>패딩)(Base64로 시작하는 클래스가 존재)
import sun.misc.BASE64Decoder;//복호화(암호화->평문으로 만들어줄때)
import sun.misc.BASE64Encoder;//암호화(평문->암호화)

public class LocalEncrypter {

	//1.암호화할때 사용되는 알고리즘->암호화시켜주는 함수(수식계산)->자리수가 많을수록,수식복잡
	private static String alogrithm="DESede";//알고리즘의 종류
	
	//2.키가필요(암호화시킬때 내부적으로 필요로하는 비밀정보)
	private static Key key=null;
	
	//3.암호화시켜주는객체->초기화시켜줘야 되는데 Cipher객체
	private static Cipher cipher=null;
	
	//4.암호화시키기위해서 필요로하는 메서드작성
	//4-1)키생성=>생성자
	private static void setUp() throws Exception {
		//암호화시키기위해서 key,chiper객체<-알고리즘
		key=KeyGenerator.getInstance(alogrithm).generateKey();//은행(보안키)
		cipher=Cipher.getInstance(alogrithm);
		System.out.println("cipher=>"+cipher+",key=>"+key);
	}
	//4-2)암호화시켜주는 메서드(평문(String)->암호화(byte[]))=>복잡한 계산->String
	private static byte[] encrypt(String input) 
	            throws InvalidKeyException,BadPaddingException,IllegalBlockSizeException{
		//1.cipher객체(암호화옵션,키이름) 초기화
		cipher.init(Cipher.ENCRYPT_MODE, key);
		//2.input=>byte[](암호화시키기위해서 담아준다.)
		byte[] inputBytes=input.getBytes();//암호화X
		//3.cipher객체의 doFinal(암호화시킬 byte[])=>암호화된 byte[] 변환
		byte[] str=cipher.doFinal(inputBytes);//암호화O
		return str;
	}
	//4-3)복호화시켜주는 메서드(암호화->평문으로 변환)
	private static String decrypt(byte[] encryptionBytes) 
		throws InvalidKeyException,BadPaddingException,IllegalBlockSizeException{
			//1.cipher객체(복호화옵션,키이름) 초기화
			cipher.init(Cipher.DECRYPT_MODE, key);
			//2.암호화된 byte[]=>정상적인 byte[]=>String으로 변환 반환
			byte[] recoveredBytes=cipher.doFinal(encryptionBytes);
			//3.byte[](평문)=>String(안녕하세요)
			String recovered=new String(recoveredBytes);
			return recovered;
	}
	//4-4)패딩(수선)입력받은문자열=>BASE64Encoder=>String(웹상에 출력)암호화
	public static String returnEncryptCode(String str)throws Exception {
		byte[] encryptionBytes=null;//암호화시켜서 담을 배열
		setUp();//key,chiper객체생성
		encryptionBytes=encrypt(str);//암호화된 숫자배열->자릿수가 부족
		//패딩작업->암호화된 몇글자를 추가로 문자열끝에 첨부
		BASE64Encoder encoder=new BASE64Encoder();
		//암호화된 byte[]값을 String으로 변환
		String encodeString=encoder.encode(encryptionBytes);
		return encodeString;//암호화된 문자열
	}
	//4-5)패딩(수선)입력받은문자열=>BASE64Decoder=>String(웹상에 출력)복호화
	public static String returnDecryptCode(String str)throws Exception{
		BASE64Decoder decoder=new BASE64Decoder();
		//원래상태 평문(복호화)문자열을 그대로 출력
		//decoder.decodeBuffer(str)=>byte[]로 변환=>최종적으로 복구된 String으로 반환
		String decode=decrypt(decoder.decodeBuffer(str));
		return decode;//안녕하세요
	}
}
===============================================
<jsp:useBean id="enc" class="encrypt.LocalEncrypter" />
<%
    request.setCharacterEncoding("utf-8");//한글처리
    String str=request.getParameter("code");//웹상에서 입력받은 문자열
    String encryptocode=null;
    if(str!=null){
    	encryptocode=enc.returnEncryptCode(str);
    }
%>
<h3>입력받은 코드값:<%=encryptocode %></h3>
<hr>
<%
    String decryptcode=enc.returnDecryptCode(encryptocode);
%>
<h3>복호화된 문자열을 출력:<%=decryptcode %></h3>
=============================================

입력받은 코드값:8AGErr8+2rNKDeUoQXzo2g==
복호화된 문자열을 출력:안녕하세요

입력받은 코드값:tSqCxblyHnKqijJv3DWTTg==  =>암호화된 부분은 매일 변경


