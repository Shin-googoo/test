3일차(자바의 암호화 구현)
********************************
package db;
/*
 *   문자열뿐만 아니라 파일까지도 암호화 또는 복호화 시켜주는 클래스
 *   암호화=>평문(텍스트)=>암호화시켜주는경우(영문자와숫자조합)
 *   복호화=>암호화=>평문으로 변경
 */
//입출력
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.security.Key;
import java.security.SecureRandom;

import javax.crypto.Cipher;//암호화할때 필요로하는 객체(init,dofinal())
import javax.crypto.CipherOutputStream;
import javax.crypto.KeyGenerator;

//<->CipherInputStream
//암호화,복호화->미완성된 클래스를 뒤에 문자열을 따로 추가=>패딩클래스
import sun.misc.BASE64Decoder;//복호화
import sun.misc.BASE64Encoder;//암호화시켜줄때 필요

public class Crypt{
	
     //파일암호화에 쓰이는 버퍼 크기 지정
    public static final int kBufferSize = 8192;//256->528->1024~
    public static java.security.Key key = null;//키생성(인증키 역할)
    //키(암호화에 필요로하는 비밀정보)를 만들어서 파일로 저장->공인인증서 처럼
    public static final String defaultkeyfileurl = "defaultkey.key";
  
    /**
    * 비밀키 생성메소드
    * @return void
    * @exception java.io.IOException,java.security.NoSuchAlgorithmException
    */
    //자바의 오버로딩 기법
    public static java.io.File makekey() //setUp()와 기능이 비슷
    throws java.io.IOException,java.security.NoSuchAlgorithmException {
        return makekey(defaultkeyfileurl);
    }

    //앞에서 입력받은 키정보를 가진 파일을 받아서 키의 정보 저장
    public static java.io.File makekey(String filename) 
    throws java.io.IOException,java.security.NoSuchAlgorithmException {
    	//파일객체생성(현재 폴더에 저장할 파일명)
    	File tempfile=new File(".",filename);
    	//1.암호화에 사용할 키를 생성->KeyGenerator객체를 생성
    	//DES=>대칭형암호형
    	KeyGenerator generator=KeyGenerator.getInstance("DES");//알고리즘(수학함수)
    	//2.초기화시켜주면서 난수를 발생(0~0.99999)
    	generator.init(new SecureRandom());//중복된값이 가능한 안나오게 설정
    	Key key=generator.generateKey();
    	//파일에 저장(공인 인증서를 생성)
    	ObjectOutputStream out=
    			new ObjectOutputStream(new FileOutputStream(tempfile));
    	out.writeObject(key);//파일에 공인인증서처럼 키를만들어서 저장(객체)
    	out.close();
    	return tempfile;
    }

    /**
    * 지정된 비밀키를 가지고 오는 메서드
    * @return Key 비밀키 클래스
    * @exception Exception
    */
    private static java.security.Key getKey() throws Exception {
       if(key!=null) {
    	   return key;//key의 정보가 들어가 있으면 리턴
       }else {//없으면 만들어서 가져와라
    	   return getKey(defaultkeyfileurl);//키이름을 부여 다시 저장
       }
    }

    private static java.security.Key getKey(String fileurl) throws Exception {
        if(key==null) {
        	File file=new File(fileurl);//defaultkey.key
        	if(!file.exists()) {//키가 존재하지 않으면 만들어서 다시 가져와라.
        		file=makekey();
        	}
        	if(file.exists()) {
        		ObjectInputStream in=
        				new ObjectInputStream(new FileInputStream(fileurl));
        		//writeObject=>파일에 저장->readObject
        		key=(Key)in.readObject();
        		System.out.println("새로 생성된 key=>"+key);
        		in.close();
        	}else {
        		throw new Exception("암호키객체를 생성할 수 없습니다.");
        	}
        }
       return key;
    }

    //문자열 대칭 암호화->id(비밀키 암호화를 희망하는 문자열),반환(암호화된 ID)
    public static String encrypt(String ID) throws Exception {
         //매개변수값이 입력하지 않았다면 처리하지 않음
    	if(ID==null || ID.length()==0) return "";
    	//1.Ciper객체를 생성->byte[] (암호화)
    	//패딩->암호화시킬때 모자란부분->임의의문자열입력
    	//DES,3DES,DES/ECB/PKCS5Padding
    	Cipher cipher=Cipher.getInstance("DES/ECB/PKCS5Padding");//수식알고리즘(패딩까지)
    	//2.Chiper초기화(암호화 옵션,키)
    	cipher.init(Cipher.ENCRYPT_MODE, getKey());//리턴받은 키정보
    	//3.암호화할 문자열->byte[]->암호화->byte[]
    	String test=ID; //UTF-8->한글데이터
    	byte[] inputBytes1=test.getBytes("UTF-8");//암호화되기 전의 byte[]
    	byte[] outputBytes1=cipher.doFinal(inputBytes1);//암호화된 후의 byte[]
    	//4.BASE64Encoder클래스->문자열끝을 보완
    	BASE64Encoder encoder=new BASE64Encoder();
    	String outputStr1=encoder.encode(outputBytes1);
    	return outputStr1;//암호화된 문자열
    }

    //codeID->복호화를 희망하는 문자열,String->복호화된 ID
    public static String decrypt(String codedID) throws Exception{
    	  //매개변수값이 입력하지 않았다면 처리하지 않음
    	if(codedID==null || codedID.length()==0) return "";
    	//1.Ciper객체를 생성->byte[] (암호화)
    	//패딩->암호화시킬때 모자란부분->임의의문자열입력
    	//DES,3DES,DES/ECB/PKCS5Padding
    	Cipher cipher=Cipher.getInstance("DES/ECB/PKCS5Padding");
    	//2.Chiper초기화(암호화 옵션,키)
    	cipher.init(Cipher.DECRYPT_MODE, getKey());//리턴받은 키정보
    	//3.암호화할 문자열->byte[]->암호화->byte[]
    	//4.BASE64Encoder클래스->문자열끝을 보완
    	BASE64Decoder decoder=new BASE64Decoder();
    	byte[] inputBytes1=decoder.decodeBuffer(codedID);//암호화된 상태
    	byte[] outputBytes2=cipher.doFinal(inputBytes1);//복호화 byte[]
    	String strResult=new String(outputBytes2,"UTF-8");
    	return strResult;
    }

    //파일대칭 암호화->infile(암호화을 희망하는 파일명->원본파일 jdbc.properties),
    //outfile(암호화된 파일명)->ktest.properites생성
    //CipherOutputStream->암호화시켜서 출력시켜주는 스트림=>출력스트림
    public static void encryptFile(String infile, String outfile) throws Exception {
    	Cipher cipher=Cipher.getInstance("DES/ECB/PKCS5Padding");//DES,3DES
    	//2.Cipher초기화
    	cipher.init(Cipher.ENCRYPT_MODE,getKey());//키정보저장 파일
    	//3.암호화을 희망하는 파일명->FileInputStream
    	FileInputStream in=new FileInputStream(infile);//jdbc.properites
    	FileOutputStream fileOut=new FileOutputStream(outfile);//암호화되길 원하는 파일
    	//4.cipher객체->암호화시킬파일 생성(암호화시킬 파일객체명,cipher객체명)
    	CipherOutputStream out=new CipherOutputStream(fileOut,cipher);
    	//5.문자열 한라인->암호화
    	byte[] buffer=new byte[kBufferSize];//8192=>파일의 내용
    	int length;
    	while((length=in.read(buffer))!=-1)//읽어들일 수 있는 상태라면
    		out.write(buffer,0,length);//배열,0,배열의크기만큼->파일에 저장
    	in.close();
    	out.close();
    }

    //infile(복호화를 희망하는 파일명)->암호화된 파일,outfile(새로 복호화된 파일명)
    public static void decryptFile(String infile, String outfile) throws Exception {
    	
    	Cipher cipher=Cipher.getInstance("DES/ECB/PKCS5Padding");//DES,3DES
    	//2.Cipher초기화
    	cipher.init(Cipher.DECRYPT_MODE,getKey());//키정보저장 파일
    	//3.복호화을 희망하는 파일명->FileInputStream(암호화된 파일)
    	FileInputStream in=new FileInputStream(infile);
    	FileOutputStream fileOut=new FileOutputStream(outfile);//복호화된 파일
    	//4.cipher객체->암호화시킬파일 생성(암호화시킬 파일객체명,cipher객체명)
    	CipherOutputStream out=new CipherOutputStream(fileOut,cipher);
    	//5.문자열 한라인->암호화
    	byte[] buffer=new byte[kBufferSize];//8192=>파일의 내용
    	int length;
    	while((length=in.read(buffer))!=-1)//읽어들일 수 있는 상태라면
    		out.write(buffer,0,length);//배열,0,배열의크기만큼->파일에 저장
    	in.close();
    	out.close();
    }



********************************

WebSecure2
       |
        -src
       |
        -WebContent
                 |
                  -input.jsp=>db파일(jdbc.properties)=>암호화=>복호화
                 |
                  -back->jdbc2.properties
==========================================

package db;

import java.io.*;//입출력
import java.sql.*;//DB
import java.util.Properties;//암호화된 파일을 불러오기위해

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class ConTest
 */
import java.io.*;

@WebServlet("/ConTest")
public class ConTest extends HttpServlet {
	
	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		response.setContentType("text/html;charset=utf-8");
		PrintWriter out=response.getWriter();
		//입력받아서 처리
		String id=request.getParameter("id");
		String pwd="";
		String decrypt=request.getParameter("decrypt");//암호화시킬파일명(test.properties)
		//Properties파일에서 불러올 키값을 변수선언
		String _driver,_url,_user,_password;
		
		if(pwd==null || "".contentEquals(pwd)) {
			try {
				//c:\webtest\10.secure\test폴더->jdbc.properties
				String location="C:/webtest/10.secure/test/jdbc.properties";
				String location2="C:/webtest/10.secure/test/"+decrypt;//test.properties
				System.out.println("location2=>"+location2);
				
				//1)DB파일 설정->암호화시켜서 암호화파일 생성
				Crypt.encryptFile(location, location2);
				//2).원본파일 삭제
				File f=new File(location);
				f.delete();//원본파일 삭제
				//3)복호화 시키기 위해서 암호화된 파일 불러오기
				Crypt.decryptFile(location2, 
						"C:/webtest/4.jsp/sou/WebSecure2/WebContent/back/jdbc3.properties");
				//복원된 파일->Properties객체를 생성->메모리에 올려서 각 키값을 확인->DB연동
				Properties props=new Properties();
				FileInputStream in=new FileInputStream
						("C:/webtest/4.jsp/sou/WebSecure2/WebContent/back/jdbc3.properties");
				props.load(in);
				in.close();
				//각 키를 분리
				_driver=props.getProperty("jdbc.drivers");
				if(_driver!=null) System.setProperty("jdbc.drivers", _driver);
				
				_url=props.getProperty("jdbc.url");
				_user=props.getProperty("jdbc.username");
				_password=props.getProperty("jdbc.password");
				System.out.println("_driver=>"+(_driver)+",_url"+(_url));
				System.out.println("_user=>"+(_user)+",_password"+(_password));
				//DB연결 테스트
				Connection con=DBConnect(_url,_user,_password);
				if(con!=null) {
					out.println("DB접속에 성공했습니다.(con)=>"+con);
				}
			}catch(Exception e) {
				e.printStackTrace();
			}
		}//if
	}
	
	public static Connection DBConnect(String _url,String _user,String _password) {
		Connection conn=null;
		try {
			Class.forName("oracle.jdbc.driver.OracleDriver");
			conn=DriverManager.getConnection(_url,_user,_password);
			System.out.println("conn=>"+conn);
		}catch(Exception e) {
			System.out.println("DB연결실패="+e);
		}
		return conn;
	}

}
===========================================





